#! /bin/bash

set -euo pipefail 

timeout=10
readonly ssh="/usr/bin/ssh -o ConnectTimeout=$timeout"
readonly separator="-"

readonly S_TimedOut="Connection timed out"
readonly S_Denied="Permission denied"
readonly S_NoRoute="No route to host"

load_hosts() {
	hosts_list=$(awk '!/^[#;]|localhost|127.0.0.1/ && NF {print $1}' $hosts_file)
	if [ $(echo "$hosts_list" | wc -l) -eq 0 ]; then 
		msg_error "Empty or malformated hosts file: $hosts_file"
	fi
}

check_get_status() {
	set +e
	status=$(ssh -o BatchMode=yes \
		-o ConnectTimeout=10 \
		-o PubkeyAuthentication=no \
		-o PasswordAuthentication=no \
		-o KbdInteractiveAuthentication=no \
		-o ChallengeResponseAuthentication=no $host 2>&1 \
		| sed 's/[^[:print:]\t]//')
	if [ "$(echo -e "$status" | awk '{print $1}')" = "ssh" ]; then
		status=$(echo -e "$status" | cut -d: -f3 | xargs)
	else
		status=$(echo -e "$status" | grep -w -o "Permission denied")
	fi
	set -e
}

check_get_uptime() {
	if [ 1 -eq $get_uptime ] || [ 1 -eq $get_all ]; then
		verbose_msg " -> server uptime" 
	   	uptime=$($ssh ${username}$host "cut -d ' ' -f 1 /proc/uptime") 
		uptime=$(convert_seconds $uptime)
	fi
}

check_get_users() {
	if [ 1 -eq $get_users ] || [ 1 -eq $get_all ]; then
		verbose_msg " -> getting users data"
	   	users=$($ssh ${username}$host cat /etc/passwd \
			| awk -F ':' '$3>=1000 {print $1}' \
			| tr '\n' ',')
	   	users=${users%,}
	fi
}

check_get_osversion() {
	if [ 1 -eq $get_os ] || [ 1 -eq $get_all ]; then
		verbose_msg " -> os version"
		osversion=$($ssh ${username}$host sh <<-'EOC'
			centos="/etc/centos-release"
			ubuntu="/etc/os-release"

			if test -f /etc/centos-release; then 
				<"$centos" sed 's/release //;s/Linux //;s/ (Core)//; y/ /-/' 
			else 
				<"$ubuntu" sed '/PRETTY/!d; s/.*="\(.*\)"/\1/; y/ /-/'
			fi
		EOC
		)
	fi
}

check_get_mem() {
	if [ 1 -eq $get_mem ] || [ 1 -eq $get_all ]; then
		verbose_msg " -> total memory"
		ram=$($ssh ${username}$host cat /proc/meminfo \
				| awk '/MemTotal/ {$2=$2/(1024^2); print $2}' \
				| xargs -I{} python -c 'print(round({}))') 
		ram=${ram%.*}
	fi
}

check_get_cpus() {
	if [ 1 -eq $get_cpucores ] || [ 1 -eq $get_all ]; then
		verbose_msg " -> cpu cores" 
	   	cpucores=$($ssh ${username}$host lscpu | awk '/^CPU\(s\)/ {print $2}')
	fi
}

run_check() {
	[ ! -z $file ] && rm -f $file
	if [ -z $host ]; then 
		load_hosts
		hosts="$hosts_list" 
		
		if [ ! -z "$environment" ]; then
			if [ "$environment" = "prod" ]; then
				msg_info "Getting data from Production servers"
				hosts=$(echo "$hosts_list" | awk '/192.148/')
			elif [ "$environment" = "dev" ]; then
				msg_info "Getting data from Development servers"
				hosts=$(echo "$hosts_list" | awk '! /192.148/')
			fi

			test -z "$hosts" && msg_error "No $environment server(s) in the list."
		fi

	else
		hosts="$host"
	fi

	if [ $file ]; then
		echo "IP-ADDRESS HOSTNAME STATUS UPTIME USERS OS-VERSION MEM-(GiB) CPU(s)" > $file
	   	verbose_msg "Writing to $file ... "
	fi
	defaultuser="root"
	local username="${defaultuser}@"
	local fetched_output=

	verbose_msg "$cmd v$VERSION begin"
	for host in $hosts; do
		[ $verbose -eq 0 ] && spinner "Gathering data..."
		[ $verbose -eq 1 ] && msg_info "Fetching data for $host"
#		verbose_msg "=== Fetching data for ${BOLD}$host${RESET} ===" 
		
		check_get_status

		if [ "$status" = "$S_Denied" ]; then 
			hostname=$($ssh ${username}$host hostname)
			status="alive"
			check_get_uptime
			check_get_users
			check_get_osversion
			check_get_mem
			check_get_cpus
		elif [ "$status" = "$S_TimedOut" ]; then
			status="rto"
			verbose_msg "   -xxx $S_TimedOut xxx-"
		elif [ "$status" = "$S_NoRoute" ]; then
			status="nr"
			verbose_msg "   -xxx $S_NoRoute xxx-"
		else
			[ $verbose -eq 1 ] && msg_warn "host down or inaccessible" && sleep 0.5
			status="unknown"
		fi
		
		output="$host ${hostname:-$separator} \
			${status:-$separator} \
			${uptime:-$separator} \
			${users:-$separator} \
			${osversion:-$separator} \
			${ram:-$separator} \
			${cpucores:-$separator}"
		output=$(sed 's/\t//g' < <(echo -e "$output"))

		if [ ! -z $file ]; then 
			echo "$output" >> $file
			[ $verbose -eq 1 ] && msg_success "$host done\n"
		else
			[ $verbose -eq 1 ] && msg_success "$host done\n"
			fetched_output="${fetched_output}\n$output"
		fi

		unset hostname uptime users osversion ram cpucores status
		[ $verbose -eq 0 ] && end_spinner
	done
	
	verbose_msg "[${GREEN}âœ”${RESET}] Fetched Successfuly"

	if [ ! -z $file ]; then
		echo
		msg_success "Data written to ${BOLD}$file${RESET}"
	else
		echo
		echo -e "$fetched_output" | column -t -s ' ' -N "IP-ADDRESS,HOSTNAME,STATUS,UPTIME,USERS,OS-VERSION,MEM-(GiB),CPU(s)" -W 4
	fi
	exit 0
}

check_main() {
	run_check
}

